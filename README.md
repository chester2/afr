# Automated Face Recognition

Python implementation of the [eigenface method](https://www.cs.ucsb.edu/~mturk/Papers/jcn.pdf) for facial recognition.



### Table of Contents

1. [Installation](#installation)
2. [Setup](#setup)
3. [Usage](#usage)
4. [Reference](#reference)



<br>
<h2 id="installation">Installation</h2>

### Requirements

- Python 3.6+
- Compatible version of [NumPy](http://www.numpy.org)
- Compatible version of [Pillow](https://python-pillow.org)



### With Git

Open the Git CLI and run:

```
pip install git+https://github.com/chester2/afr.git
```



### Without Git

Extract the entire archive to a directory, cd there from a command line, then run:
```
python setup.py install
```



<br>
<h2 id="setup">Setup</h2>

### General Configuration

Navigate to

    (path to Python)/Lib/site-packages/afr/config/

Configure `config.ini`.



### Database of Known Individuals

Let us assume that we want to add the [Yale Face Database](http://vismod.media.mit.edu/vismod/classes/mas622-00/datasets/YALE/) (`yalefaces.tar.gz` on that page) to AFR. We observe that:
- All images in the set are of resolution `320x243`
- The string pattern `subjectX.` in an image's filename identifies that image as belonging to the person (or class) corresponding to index `X`
- `X` begins counting from 1
- `X` does not count past 15

Let us name this database or set `yalefaces` and store all training images in `C:/yf_training/`. Navigate to

    C:/yf_training/

For all images with class index `01` to `09` in the filename, remove the leading zeros. Next, navigate to

    (path to Python)/Lib/site-packages/afr/config/

Open `sets.ini` and add the following section:

    [yalefaces]
    width=320
    height=243
    pfx=subject
    sfx=.
    init=1
    end=15
    path=C:/yf_training/
    names=

*`pfx` and `sfx` may have empty values.

**`init` is the non-negative integer that class index counting starts from (in the filename). `end` is where counting stops. Internally, AFR always begins counting from 0.

***`names` is a comma-separated list, where the first item is the name of the individual with class index `init`, the next item corresponds to class index `init+1`, etc. `names` may be valueless. If it does have a value, then the number of comma-separated entries must exactly match the number of classes in the set.



<br>
<h2 id="usage">Usage</h2>

Given set `abc`:<br>
If `abc` was newly added to AFR, if `abc`'s training images were modified, or if `abc`'s `set.ini` metadata was modified, then run the following in order:

    afr.pca('abc')
    afr.eigf('abc')

It is now possible to perform identification using `afr.cmc()` and `afr.knn()`. It is also now possible to use the `rmk` functions.

**Sample execution in interactive mode:**

    python
    >>> import afr
    >>> sn = 'yalefaces'
    >>> afr.pca(sn)
    >>> afr.eigf(sn)
    >>> afr.knn('man1.jpg', sn, 5, rmk=True)
    7
    >>>



<br>
<h2 id="reference">Reference</h2>

<code>afr.<b>pca</b>(<i>setname</i>)</code><br>
Use _setname_'s training images to find the mean training image, the normalized eigenfaces, and the eigenfaces' eigenvectors. These are saved to disk as numpy array files.
<br>
<br>

<code>afr.<b>eigf</b>(<i>setname</i>)</code><br>
Reads numpy arrays of _setname_'s mean and eigenfaces (generated by `afr.pca()`) and computes the eigenface weights for each training image.

Weights for images belonging to one class are grouped into an array. These arrays are saved to disk as numpy array files.

Computes the average weight for each class as a column vector. Collects all average weights into a single matrix and saves to disk as a numpy array file.
<br>
<br>

<code>afr.<b>cmc</b>(<i>filename, setname, dim=0, rmk=False</i>)</code><br>
Returns a 2-tuple after performing class mean classification (average all images within a class and find the closest class). The first element is the index of the matched class. The second element is the matched individual's name (will be an empty string if in `sets.ini`, _setname_'s `names` property is valueless).

_filename_ is the full filename of the to-be-identified image.

_dim_ is the number of eigenfaces to use (e.g. giving it the value 10 indicates to use the 10 eigenfaces with the largest eigenvalues). Set _dim_ to 0 to use all eigenfaces.

If _rmk_ is `True`, exports the to-be-identified image's eigenface reconstruction.
<br>
<br>

<code>afr.<b>knn</b>(<i>filename, setname, k, dim=0, rmk=False</i>)</code><br>
Alterative to `afr.cmc()` with the same return value. Performs k-nearest neighbors identification.

_k_ is a positive integer. The largest reasonable value to pass is the size of the smallest class.
<br>
<br>

<code>afr.<b>listtbi</b>()</code><br>
Returns a lists of filenames of all files in the to-be-identified directory.
<br>
<br>

<code>afr.<b>rmk_img</b>(<i>filepath, setname</i>)</code><br>
Exports the eigenface reconstruction of an image (given by _filepath_).
<br>
<br>

<code>afr.<b>rmk_mean</b>(<i>setname</i>)</code><br>
Exports _setname_'s mean training face.
<br>
<br>

<code>afr.<b>rmk_eigfs</b>(<i>setname</i>)</code><br>
Exports _setname_'s eigenfaces as human-viewable images.
<br>
<br>

<code>afr.<b>rmk_cmeans</b>(<i>setname</i>)</code><br>
Exports the mean face for each _stename_ class.